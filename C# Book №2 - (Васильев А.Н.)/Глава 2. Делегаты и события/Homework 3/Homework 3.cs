/*Напишите программу, в которой объявлен делегат, предназначен-
ный для работы с методами, не имеющими аргумента и возвращающи-
ми символьный результат. Опишите класс, у которого есть текстовое
поле, а также закрытое поле, являющееся ссылкой на экземпляр деле-
гата. В классе нужно описать открытое свойство, доступное только для
чтения. Значением свойства является значение закрытого поля (то есть
ссылка на экземпляр делегата). Опишите конструктор класса с двумя
аргументами: текстовым (тип string) и логическим (тип bool). Пер-
вый текстовый аргумент определяет значение текстового поля объекта,
а второй логический аргумент определяет значение закрытого поля типа
делегата. Если второй аргумент истинный, то закрытому полю значени-
ем присваивается анонимный метод (или лямбда-выражение), возвра-
щающий результатом первый символ из текстового поля. Если логиче-
ский аргумент ложный, то закрытому полю значением присваивается
анонимный метод (или лямбда выражение), возвращающий результа-
том последний символ из текстового поля. Создайте объекты класса
и проверьте функциональность свойства: его можно вызывать как метод,
без аргументов, а результатом является первый или последний символ
в текстовом поле (в зависимости от того, с каким логическим аргумен-
том создавался объект).*/

using System;

namespace Homework_3
{
    delegate char TestDelegat();

    class MyClass
    {
        private string _text;
        private TestDelegat testDelegat; 

        public TestDelegat GetDelegate
        {
            get {return testDelegat;}
        }

        public MyClass(string text, bool switcher)
        {
            _text = text;

            if (switcher == true) testDelegat = () => _text[0];
            else testDelegat = () => _text[_text.Length - 1];
        }
    }

    internal class Program
    {
        static void Main(string[] args)
        {
            MyClass obj = new MyClass("texts", true);
            MyClass obj2 = new MyClass("texts", false);
            Console.WriteLine(obj.GetDelegate());
            Console.WriteLine(obj2.GetDelegate());
        }
    }
}